---
title: 'í•©ìŠ¹ íƒì‹œ ìš”ê¸ˆ'
metaTitle: 'ë§Œë ™ ê°œë°œì í‚¤ìš°ê¸°'
metaDescription: '2021 ì¹´ì¹´ì˜¤ ë¸”ë¼ì¸ë“œ ì±„ìš© ê¸°ì¶œ ë¬¸ì œ í’€ì´ì…ë‹ˆë‹¤.'
tags: ['2021 ì¹´ì¹´ì˜¤ ë¸”ë¼ì¸ë“œ']
date: '2021-02-28'
---

# ë¬¸ì œ

- [ì¹´ì¹´ì˜¤ 2021 ë¸”ë¼ì¸ë“œ ê³µê°œ ì±„ìš©. 4ë²ˆ í•©ìŠ¹ íƒì‹œ ìš”ê¸ˆ](https://programmers.co.kr/learn/courses/30/lessons/72413)

## ì½”ë“œ

<details><summary> ì½”ë“œ ë³´ê¸° </summary>

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Scanner;

class Edge{
    int dst, cost;

    public Edge(int dst, int cost) {
        this.dst = dst;
        this.cost = cost;
    }
}

class Solution {
    static int ans = 987654321;
    static int dist[], dp[][];
    static List<Edge> adj[];
    public static int solution(int n, int s, int a, int b, int[][] fares) {
        dist = new int[n + 1];
        Arrays.fill(dist, 987654321);
        adj = new List[n + 1];
        dp = new int[n + 1][n + 1];

        for (int i = 0; i <= n; i++) {
            adj[i] = new ArrayList<>();
            Arrays.fill(dp[i], 987654321);
        }

        for (int[] fare : fares) {
            int u = fare[0];
            int v = fare[1];
            int c = fare[2];
            dp[u][v] = dp[v][u] = c;
            adj[u].add(new Edge(v, c));
            adj[v].add(new Edge(u, c));
        }

        getFloyd(n);
        dijkstra(s, a, b);
        return ans;
    }

    private static void getFloyd(int n) {
        for (int k = 1; k <= n ; k++) {
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= n; j++) {
                    if(i == j) dp[i][j] = 0;
                    else{
                        if(dp[i][j] > dp[i][k] + dp[k][j])
                            dp[i][j] = dp[i][k] + dp[k][j];
                    }
                }
            }
        }
    }

    private static void dijkstra(int s, int a, int b) {
        PriorityQueue<Edge> pq = new PriorityQueue<>((c, d) -> (c.cost - d.cost));
        pq.add(new Edge(s, 0));
        dist[s] = 0;
        while (!pq.isEmpty()) {
            Edge now = pq.poll();
            int cur = now.dst, curCost = now.cost;
            if(dist[cur] < curCost) continue;
            ans = Math.min(ans, curCost + dp[cur][a] + dp[cur][b]);
            for (Edge edge : adj[cur]) {
                int next = edge.dst;
                int nextCost = edge.cost;
                if(dist[next] > curCost + nextCost){
                    dist[next] = curCost + nextCost;
                    pq.add(new Edge(next, dist[next]));
                }
            }
        }
    }
}
```

</details>

## â­ï¸ëŠë‚€ì â­ï¸

> ì•ì„  ë¬¸ì œë“¤ì— ë¹„í•´ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ê²ƒì´ ìˆ˜ì›”í–ˆë‹¤.
>
> ê·¸ë˜í”„ ê´€ë ¨ ë¬¸ì œëŠ” ë§ì´ í’€ì–´ë´ì„œ ìµìˆ™í–ˆë˜ ê²ƒì´ ì»¸ë˜ ê²ƒ ê°™ë‹¤.
>
> í’€ê³ ë‚˜ì„œ ë‹¤ë¥¸ ì‚¬ëŒë“¤ í’€ì´ë¥¼ ë´¤ëŠ”ë°, êµ³ì´ ë‹¤ìµìŠ¤íŠ¸ë¼ë¡œ ìµœë‹¨ ê²½ë¡œ ì´ë™í•˜ë©´ì„œ ëª©ì ì§€ê¹Œì§€ ë‹¤ì‹œ ìµœë‹¨ê²½ë¡œë¥¼ ì“¸ í•„ìš”ê°€ ì—†ì„ ê²ƒ ê°™ë‹¤
>
> ë‚˜ëŠ” ë‹¤ìµìŠ¤íŠ¸ë¼ + í”Œë¡œì´ë“œë¥¼ ëª¨ë‘ ì‚¬ìš©í–ˆëŠ”ë°, ë‘˜ ì¤‘ í•˜ë‚˜ë§Œ ì‚¬ìš©í•´ë„ í•´ê²°ì´ ê°€ëŠ¥í•˜ë‹¤.

## í’€ì´ ğŸ“£

<hr/>

1ï¸âƒ£ í”Œë¡œì´ë“œ ì™€ìƒ¬ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•´ì„œ ëª¨ë“  ì§€ì ê°„ì— ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•´ ë†“ëŠ”ë‹¤

2ï¸âƒ£ ì‹œì‘ì ì—ì„œ ì¸ì ‘í•œ ì§€ì  ì¤‘ ê°€ì¥ ë¹„ìš©ì´ ìµœì†Œë¡œ í•˜ëŠ” ì§€ì ë¶€í„° ì´ë™í•´ì„œ ê·¸ ìë¦¬ì—ì„œ ëª©ì ì§€ê¹Œì§€ì˜ ìµœì†Œ ë¹„ìš©ì„ êµ¬í•œë‹¤.

    - ìµœì†Œ í™ì„ ì´ìš©í•´ ë¹„ìš©ì´ ê°€ì¥ ì ì€ ê°„ì„ ì„ ì„ íƒí•´ ì´ë™í•œë‹¤.

    - ì´ë™í•œ ì§€ì ì—ì„œ ëª©ì ì§€ê¹Œì§€ í”Œë¡œì´ë“œ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•´ êµ¬í•´ë†“ì€ ìµœë‹¨ ê²½ë¡œë¥¼ í†µí•´ ìµœì†Œ ë¹„ìš©ì„ êµ¬í•œë‹¤.

    - ìµœì†Œ íƒì‹œ í•©ìŠ¹ ë¹„ìš©ê³¼ ë¹„êµí•´ì„œ ìµœì†Œê°’ì„ ìœ ì§€í•œë‹¤.

3ï¸âƒ£ ìœ„ì˜ ê³¼ì •ì„ ë°˜ë³µí•´ì„œ ëª¨ë“  ì§€ì ê¹Œì§€ì˜ ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ ì´ë™í•œ í›„, ê·¸ê³³ì—ì„œ ëª©ì ì§€ê¹Œì§€ ë˜ ìµœì†Œë¹„ìš©ì„ êµ¬í•œë‹¤.

4ï¸âƒ£ ìµœì¢…ì ìœ¼ë¡œ êµ¬í•œ ìµœì†Œë¹„ìš©ì„ ì¶œë ¥í•œë‹¤.

<hr/>
