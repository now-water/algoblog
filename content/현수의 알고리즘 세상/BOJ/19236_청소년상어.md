---
title: '19236. ì²­ì†Œë…„ìƒì–´'
metaTitle: 'ë§Œë ™ ê°œë°œì í‚¤ìš°ê¸°'
metaDescription: 'ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œë¥¼ í’€ê³  ì •ë¦¬í•œ ê³³ì…ë‹ˆë‹¤.'
tags: ['êµ¬í˜„', 'ë°±íŠ¸ë˜í‚¹', 'ì‹œë®¬ë ˆì´ì…˜']
date: '2021-01-17'
---

# ë¬¸ì œ

- [19236. ì²­ì†Œë…„ ìƒì–´](https://www.acmicpc.net/problem/19236)

## ì½”ë“œ

<details><summary> ì½”ë“œ ë³´ê¸° </summary>

```javascript
#include <iostream>
#include <queue>
#include <stack>
#include <vector>
#include <list>
#include <functional>
#include <algorithm>
#include <string>
#include <cstring>
#include <cmath>
#include <map>
#include <set>
#include <bitset>
#include <unordered_map>
#include <unordered_set>
#define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
#define ll long long
#define pii pair<int, int>
#define pll pair<ll, ll>
#define INF 987654321
using namespace std;

struct Pos
{
	int x, y, dir;

	void swap(Pos& a)
	{
		Pos temp;
		temp.x = x; temp.y = y;
		x = a.x; y = a.y;
		a.x = temp.x; a.y = temp.y;
	}
};
int dx[9] = {0, -1, -1, 0, 1, 1, 1, 0, -1 };
int dy[9] = {0, 0, -1, -1, -1, 0, 1, 1, 1 };

bool isBorder(int x, int y)
{
	return (x >= 0 && x < 4 && y >= 0 && y < 4);
}
void fish_move(vector<Pos>& fishes, vector<vector<int>>& fmap, const vector<bool>& survived_fishes, Pos shark)
{
	for (int fish = 1; fish <= 16; ++fish)
	{
		if (survived_fishes[fish])
		{
			int d = fishes[fish].dir, x = fishes[fish].x, y = fishes[fish].y;
			int nx, ny, change_dir_cnt = 0;

			/* Change direction of a fish */
			while (change_dir_cnt < 8)
			{
				nx = x + dx[d]; ny = y + dy[d];
				if (isBorder(nx, ny) && (shark.x != nx || shark.y != ny))
					break;
				change_dir_cnt += 1;
				d = (d + 1) % 9;
				if (d == 0) d += 1;
				if (change_dir_cnt == 8)
				{
					nx = x; ny = y;
					break;
				}
			}

			/* There is no way to change direction of a fish */
			if (x == nx && y == ny) continue;

			/* Change position between fishes in the two sections */
			fishes[fish].dir = d;
			int next_fish = fmap[nx][ny];
			fishes[fish].swap(fishes[next_fish]);
			swap(fmap[nx][ny], fmap[x][y]);
		}
	}
}
int shark_move(vector<Pos> fishes, vector<vector<int>> fmap, vector<bool> survived_fishes, Pos shark)
{
	fish_move(fishes, fmap, survived_fishes, shark);

	int d = shark.dir;
	int nx = shark.x, ny = shark.y;
	vector<pii> canMove;
	while (1)
	{
		nx += dx[d]; ny += dy[d];
		if (isBorder(nx, ny))
		{
			if (survived_fishes[fmap[nx][ny]])
				canMove.push_back(pii(nx, ny));
		}
		else break;
	}
	if (canMove.empty()) return 0;
	int ret = 0;
	for (auto& spos : canMove)
	{
		int fish_idx = fmap[spos.first][spos.second];
		Pos fish = fishes[fish_idx];
		shark = fish; // Shark ate a fish !!!!!!
		survived_fishes[fish_idx] = false; // Then, the fish is dead..
		ret = max(ret, fish_idx + shark_move(fishes, fmap, survived_fishes, shark));
		survived_fishes[fish_idx] = true; // fish revived !
	}
	return ret;
}
int main()
{
	vector<vector<int>> fmap(4, vector<int>(4, 0));
	vector<Pos> fishes(17);
	for (int i = 0; i < 4; ++i)
	{
		for (int j = 0; j < 4; ++j)
		{
			int num, d;
			cin >> num >> d;
			fmap[i][j] = num;
			fishes[num].x = i; fishes[num].y = j; fishes[num].dir = d;
		}
	}
	Pos shark = { 0, 0, fishes[fmap[0][0]].dir };
	vector<bool> living_fishes(17, true);
	living_fishes[fmap[0][0]] = false;
	int first_score = fmap[0][0];
	cout << first_score + shark_move(fishes, fmap, living_fishes, shark) << '\n';
}
```

</details>

## â­ï¸ëŠë‚€ì â­ï¸

> ì•„ê¸° ìƒì–´ë¥¼ í’€ê³  ì¢€ ì˜¤ë˜ ì§€ë‚˜ì„œ ì²­ì†Œë…„ ìƒì–´ë¥¼ í’€ì–´ë´¤ëŠ”ë°, ê·¸ë•Œ ë§Œí¼ ì˜¤ë˜ ê±¸ë¦¬ì§„ ì•Šì•˜ë‹¤. ì¡ì•„ë¨¹ì€ ë¬¼ê³ ê¸°ë¥¼ ì²´í¬í•´ì¤„ ë•Œ ì¢Œí‘œê°’ìœ¼ë¡œ -1ë¡œ ì„¤ì •í•´ì£¼ì—ˆëŠ”ë°, ì´ ê²ƒ ë•Œë¬¸ì— ë§ˆì§€ë§‰ì— ë””ë²„ê¹…í•˜ëŠ”ë° ì• ë¨¹ì—ˆë‹¤! (out of index error...)

<hr/>

## í’€ì´ ğŸ“£

1ï¸âƒ£ 1~16ë²ˆ ë¬¼ê³ ê¸°ëŠ” ìˆœì„œëŒ€ë¡œ ìì‹ ì´ ë°”ë¼ë³´ê³  ìˆëŠ” ë°©í–¥ì˜ ë¬¼ê³ ê¸°ì™€ ìë¦¬ë¥¼ ë°”ê¾¼ë‹¤. êµ¬ì¡°ì²´ì— (xì¢Œí‘œ, yì¢Œí‘œ, ë°©í–¥) ìœ¼ë¡œ ì €ì¥í•´ë‘”ë‹¤.

2ï¸âƒ£ 4\*4 ê³µê°„ì— ê° ì¹¸ì— ì €ì¥ë˜ì–´ ìˆëŠ” ë¬¼ê³ ê¸°ì˜ ì¸ë±ìŠ¤ë¥¼ ë”°ë¡œ ì €ì¥í•œë‹¤.

3ï¸âƒ£ ë§Œì•½ ë°”ë¼ë³´ëŠ” ë°©í–¥ìœ¼ë¡œ ì´ë™í•  ìˆ˜ ì—†ë‹¤ë©´ ë°˜ì‹œê³„ë°©í–¥ìœ¼ë¡œ 45ë„ì”© íšŒì „ì‹œí‚¨ë‹¤. ì´ë™ì´ ê°€ëŠ¥í•œ ë°©í–¥ìœ¼ë¡œ í•´ë‹¹ ë²ˆí˜¸ì˜ ë¬¼ê³ ê¸° ë°©í–¥ì„ ì¬ì„¤ì •í•´ì¤€ë‹¤.

4ï¸âƒ£ ë¬¼ê³ ê¸°ì˜ ì´ë™ì´ ì™„ë£Œë˜ë©´ ìƒì–´ê°€ ì›€ì§ì´ëŠ”ë°, ë°”ë¼ë³´ëŠ” ë°©í–¥ì— ìˆëŠ” ëª¨ë“  ë¬¼ê³ ê¸°ë“¤ì˜ ì¢Œí‘œë¥¼ ì €ì¥í•´ë‘ê³  ì¬ê·€í˜¸ì¶œë¡œ í•˜ë‚˜ì”© í•´ê²°í•œë‹¤.

5ï¸âƒ£ ì´ ë•Œ, ê° ìƒì–´ì˜ ì´ë™ì— ë”°ë¼ ë¬¼ê³ ê¸°ë“¤ì´ ì €ì¥ë˜ìˆëŠ” 2ì°¨ì› ë²¡í„°ì™€, í˜„ì¬ê¹Œì§€ ìƒì–´ê°€ ì¡ì•„ë¨¹ì€ ë¬¼ê³ ê¸°ë“¤ì„ í‘œì‹œí•˜ëŠ” 1ì°¨ì› ë²¡í„°ë¥¼ ê° ì¬ê·€í•¨ìˆ˜ë¡œ call-by-value í˜•íƒœë¡œ ì „ë‹¬í•´ì¤€ë‹¤.

6ï¸âƒ£ ê°ê°ì˜ ì¬ê·€í•¨ìˆ˜ì—ì„œëŠ” (ë…ë¦½ëœ ë¬¼ê³ ê¸° 2ì°¨ì› ë²¡í„°ì™€, ì‚´ì•„ìˆëŠ” ë¬¼ê³ ê¸° 1ì°¨ì› ë²¡í„°, ìƒì–´ì˜ ìœ„ì¹˜)ê°€ ì´ìš©ëœë‹¤.

7ï¸âƒ£ ìƒì–´ê°€ ë” ì´ìƒ ì¡ì•„ë¨¹ì„ ìˆ˜ ìˆëŠ” ë¬¼ê³ ê¸°ê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ë•Œ ê¹Œì§€ ë¬¼ê³ ê¸° ì´ë™ -> ìƒì–´ ì´ë™ ìˆœìœ¼ë¡œ ê³„ì†í•´ì„œ ìœ„ì˜ ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.

8ï¸âƒ£ ë” ì´ìƒ ì§„í–‰í•˜ì§€ ëª»í•˜ë©´ 0ì„ ë¦¬í„´í•œë‹¤.

9ï¸âƒ£ í˜„ì¬ ìƒì–´ì˜ ìœ„ì¹˜ì—ì„œ ê°€ëŠ¥í•œ ì´ë™ ê²½ìš° ì¤‘ ìµœëŒ€ê°’ì„ ê°€ì§ˆ ìˆ˜ ìˆëŠ” ê²½ìš°ì˜ ë¦¬í„´ê°’ì„ ë°˜í™˜í•œë‹¤.

<hr/>

## ì‹¤ìˆ˜ ğŸ˜…

- ì´ë¯¸ ì¡ì•„ë¨¹ì€ ë¬¼ê³ ê¸°ë¥¼ ë‹¤ì‹œ ì²˜ë¦¬í•˜ì§€ ì•Šìœ¼ë ¤ê³  -1ë¡œ ê°’ì„ ì„¤ì •í–ˆëŠ”ë° ì¸ë±ìŠ¤ ì—ëŸ¬ê°€ ëœ¨ë©´ì„œ ê³„ì†í•´ì„œ ëŸ°íƒ€ì„ ì—ëŸ¬ ë‘ë‘¥..
- í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ì–´ì„œ swap í•¨ìˆ˜ë¥¼ ì˜¤ë²„ë¡œë”©í•˜ëŠ” êµ¬í˜„ì„ í—¤ë§¤ë‹¤ê°€ í•˜ë‚˜ì”© í•´ë³´ë©´ì„œ ì™„ì„±í–ˆë‹¤..!
