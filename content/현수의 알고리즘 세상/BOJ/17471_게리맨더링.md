---
title: '17471. ê²Œë¦¬ë§¨ë”ë§'
metaTitle: 'ë§Œë ™ ê°œë°œì í‚¤ìš°ê¸°'
metaDescription: 'ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œë¥¼ í’€ê³  ì •ë¦¬í•œ ê³³ì…ë‹ˆë‹¤.'
tags: ['ê·¸ë˜í”„ ì´ë¡ ', 'ê·¸ë˜í”„ íƒìƒ‰', 'ë¸Œë£¨íŠ¸í¬ìŠ¤', 'BFS']
date: '2021-01-17'
---

# ë¬¸ì œ

- [17471.ê²Œë¦¬ë§¨ë”ë§](https://www.acmicpc.net/problem/17471)

## ì½”ë“œ

<details><summary> ì½”ë“œ ë³´ê¸° </summary>

```c
#include <iostream>
#include <queue>
#include <stack>
#include <vector>
#include <list>
#include <functional>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <bitset>
#include <unordered_map>
#include <unordered_set>
#include <cstring>
#include <cmath>
#include <cstdio>
#define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
#define ll long long
#define pii pair<int, int>
#define pll pair<ll, ll>
#define INF 987654321
#define endl '\n'
#define vec vector<int>
#define vec2 vector<vector<int>>
#define FOR(i, n) for(int i=0; i<n; ++i)

using namespace std;
int n;
bool visited[11];
vec2 adj;
vec population;
// ì´ˆê¸°í™”
void init()
{
	FASTIO
		cin >> n;
	population = vec(n + 1, 0);
	adj = vec2(n + 1);
	for (int i = 1; i <= n; i++)
		cin >> population[i];
	for (int i = 1; i <= n; i++)
	{
		int cnt, district; cin >> cnt;
		FOR(j, cnt)
		{
			cin >> district;
			adj[i].push_back(district);
			adj[district].push_back(i);
		}
	}
}
bool isConn(const vec& a, const vec& b)
{
	unordered_set<int> ua, ub;
	for (auto& elem : a) ua.insert(elem);
	for (auto& elem : b) ub.insert(elem);

	queue<int> aq, bq;
	aq.push(a[0]); bq.push(b[0]);
	memset(visited, 0, sizeof(visited));
	visited[a[0]] = true;
	while (!aq.empty())
	{
		int here = aq.front(); aq.pop();
		for (auto& elem : adj[here])
		{
			if (!visited[elem] && ub.find(elem) == ub.end()) // find(a.begin(), a.end(), elem) != a.end() ìœ¼ë¡œë„ ê°€ëŠ¥!!!
			{
				visited[elem] = true;
				aq.push(elem);
			}
		}
	}
	for(auto& elem: a)
		if (!visited[elem])
			return false;

	memset(visited, 0, sizeof(visited));
	visited[b[0]] = true;
	while (!bq.empty())
	{
		int here = bq.front(); bq.pop();
		for (auto& elem : adj[here])
		{
			if (!visited[elem] && ua.find(elem) == ua.end())
			{
				visited[elem] = true;
				bq.push(elem);
			}
		}
	}
	for (auto& elem : b)
		if (!visited[elem])
			return false;
	return true;
}
int seperate(vec a, vec b, int idx)
{
	if (idx > n)
	{
		if (a.size() == 0 || b.size() == 0 || !isConn(a, b))
			return INF;
		int asum = 0, bsum = 0;
		for (auto& elem : a) asum += population[elem];
		for (auto& elem : b) bsum += population[elem];
		return abs(asum - bsum);
	}
	a.push_back(idx);
	int minValue = seperate(a, b, idx + 1);
	a.pop_back();
	b.push_back(idx);
	return min(minValue, seperate(a, b, idx + 1));
}
void calc()
{
	vec a, b;
	int ans = seperate(a, b, 1);
	cout << (ans == INF ? -1 : ans ) << endl;
}
int main()
{
	init();
	calc();
}
```

</details>

## â­ï¸ëŠë‚€ì â­ï¸

> ì´ë˜ì €ë˜ ë§ì´ ëŒì•„ì˜¤ë©´ì„œ í•´ê²°í•œ ë¬¸ì œ. ê·¸ë˜ë„ í•œ ê°€ì§€ ë°©ë²•ì— ê°‡íˆì§€ ì•Šê³  ì—¬ëŸ¬ ë°©ë²•ìœ¼ë¡œ ì‹œë„í•´ë³¸ ëì— í•´ê²°!! êµ¬ìš·~~

## í’€ì´ ğŸ“£

<hr/>

1ï¸âƒ£ì¸ì ‘ë¦¬ìŠ¤íŠ¸ë¥¼ êµ¬í•´ë†“ê³  ì‹œì‘í•œë‹¤.

2ï¸âƒ£ê° ì§€ì ë“¤ì„ ì¡°í•©íƒìƒ‰ì„ ì‹¤ì‹œí•˜ê³ , ê° ì¡°í•©ì— ëŒ€í•´ì„œ ë¬¸ì œì˜ ì¡°ê±´ì„ ë”°ì ¸ë³¸ë‹¤.

3ï¸âƒ£ê° ì„ ê±°êµ¬ì˜ êµ¬ì—­ë“¤ì€ ì„œë¡œ ì¸ì ‘í•´ìˆì–´ì•¼í•œë‹¤. -> ì¸ì ‘ë¦¬ìŠ¤íŠ¸ë¥¼ í†µí•´ ì—°ê²°ë˜ëŠ”ì§€ë¥¼ íŒŒì•…í•˜ê¸° ìœ„í•´ BFSë¥¼ ì‹¤ì‹œí•œë‹¤.

4ï¸âƒ£ë‘ ì„ ê±°êµ¬ì˜ êµ¬ì—­ë“¤ì´ ëª¨ë‘ ì¸ì ‘í•´ìˆë‹¤ë©´ ê·¸ ë•Œì˜ ì¸êµ¬ ì°¨ì´ê°’ì„ êµ¬í•´ì„œ ìµœì†Œê°’ì„ êµ¬í•œë‹¤.

<hr/>

## ì‹¤ìˆ˜ ğŸ˜…

- BFS ëŒ€ì‹  union-findë¡œ ê° ì„ ê±°êµ¬ì˜ êµ¬ì—­ë“¤ì´ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ ì°¾ì•„ë³´ë ¤ë‹¤ê°€ ì‹¤íŒ¨.. ì„œë¡œ ë–¨ì–´ì ¸ìˆëŠ” êµ¬ì—­ì´ í•œ ì„ ê±°êµ¬ì¼ ë•Œ ì´ì–´ì ¸ìˆë‹¤ë©´ ê²°êµ­ ê°™ì€ ë¶€ëª¨ë¥¼ ê°€ì ¸ì„œ trueê°€ ë˜ë²„ë¦¼..
- DFS ë¥¼ ì‚¬ìš©í•´ì„œ ê° ì„ ê±°êµ¬ì˜ êµ¬ì—­ë“¤ì´ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ ì°¾ì•„ë³´ë‹¤ê°€ ì‹¤íŒ¨.

## ë‹¤ë¥¸ í’€ì´ ë°©ë²• ê³ ì•ˆ ğŸ§

> ë¹„íŠ¸ì…‹ìœ¼ë¡œ ì¡°í•©êµ¬í•˜ëŠ” ë°©ë²•

```c
for(int m = 0; m < (1 << n); ++m){
		vector<int> vec1, vec2;
		int k = m;
		for(int i = 1; i <= n; ++i){
			if(k % 2 == 1){
				vec1.push_back(i);
			}else{
				vec2.push_back(i);
			}
			k /= 2;
		}
		int sum1 = 0, sum2 = 0;
		bool conn1 = connected(amt, adj, vec1, n, sum1);
		bool conn2 = connected(amt, adj, vec2, n, sum2);
		if(conn1 && conn2 && ret > abs(sum1 - sum2)){
			ret = abs(sum1 - sum2);
		}
}
```
