---
title: '(1) 분산 시스템 설계 및 핵심 고려사항'
metaTitle: '만렙 개발자 키우기'
metaDescription: '확장성 있는 웹 아키텍처와 분산 시스템에 관한 정리입니다'
tags: ['Backend']
date: '2021-05-22'
---

확장성 있는 웹 사이트나 웹 애플리케이션을 만들고 관리한다는 것이란 무엇인가.

매우 기초적인 의미에서 확장성 있는 웹 사이트란 사용자들이 인터넷을 통해 원격지의 자원에 연결할 때, 자원이나 자원에 대한 접근 권한이 여러 개의 서버에 분산되어 있을 때를 말한다.

# 대규모 웹 시스템 설계 시 고려사항

## 가용성(Availability)

- 웹 사이트의 가용성은 많은 회사의 명성과 기능에 절대적으로 중요하다.

* 예를 들어 `Amazon.com`과 같은 온라인 마켓 사이트에서 몇 분간 서비스가 제대로 동작하지 않으면, 회사는 수천 혹은 수만 달러의 손실을 입는다.

- 따라서 **항상 가용적이고 장애에 유연한 아키텍처를 가지는 것은 가장 기본적인 비즈니스 요구사항**이다.

* 분산 시스템에서 높은 가용성을 얻기 위해, **중요한 컴포넌트의 이중화**와 **실패가 발생했을 경우에 대한 빠른 복구 방법**, **문제가 발생할 때 일부만으로 동작할 수 있게 해 전면 장애가 발생하지 않게 하는 구성(graceful degradation)** 에 대한 고려가 필요하다.

## 성능(Performance)

- 대부분 웹 사이트에서 성능은 매우 중요한 고려사항이다.

* 웹사이트의 속도는 사용성, 만족도 뿐만 아니라, 수익 및 유지에 직접적으로 연관있는 검색 엔진의 랭킹에도 중요한 영향을 미친다.

- 결과적으로 빠른 응답 시간과 낮은 레이턴시를 위해 최적화된 시스템을 만드는 것이 중요하다.

## 신뢰성(Reliability)

- 항상 똑같은 요청에는 똑같은 결과를 제공해야 한다.

* 즉, 시스템이 항상 정상적으로 동작해야 한다는 의미이다.

- 데이터가 변하거나 업데이트되고 나면 업데이트된 새로운 데이터를 반환해야 한다.

* 어떤 데이터가 시스템에 저장된 이후 사용자가 해당 데이터를 검색할 때 항상 그 결과가 반환된다는 것을 사용자들에게 알게 할 필요가 있다.

## 확장성(Scalability)

- 대규모 분산 시스템에서라면 규모 자체는 확장성에서 고려해야 할 하나의 측면에 불과하다.

* 중요한 것은 더 많은 부하를 처리할 수 있도록 처리량을 증가시키기 위해 필요한 노력이다.

- 시스템의 확장성이란 시스템의 여러 특징이나 기능/비기능 한계 상황으로 설명될 수 있다.

## 관리성(Manageability)

- 쉽게 운용할 수 있는 시스템을 설계하는 것도 중요한 고려 사항이다.

* 시스템의 관리성이란 운용(유지와 업데이트)의 확장성과 같은 말이다.

- 관리성이 좋아지려면 문제 발생 시 분석이 용이해야 하며 문제를 이해하기 쉬워야 한다.

* 업데이트와 수정, 시스템 운용 자체가 쉬워야 한다.

## 비용(Cost)

- 하드웨어와 소프트웨어 비용을 포함하여 시스템을 배포하고 관리하는 비용도 중요하게 고려해야 한다.

* 이러한 비용에는 시스템이 빌드하는데 걸리는 시간, 시스템을 실행시키는데 드는 운용 노력의 양, 모든 고려해야 할 사항에 대해 필요한 교육 비용까지 포함된다.

- 즉, 비용은 시스템 소유에 필요한 모든 비용이다.

### 트레이드 오프 관계

이러한 고려 사항들은 분산 웹 시스템을 설게할 때 판단 기준으로 사용할 수 있다.

하지만 어느 하나를 향상시키는 것은 다른 하나의 하락을 가져올 수도 있다.

> 예를 들면, 처리량을 향상 시키기 위해서는 서버를 여러 개 추가하는 것(수평적 확장)은 서버를 여러 개 추가로 관리해야 하기 때문에 관리성과 비용 측면에서 좋지 않다.

무엇이 옳은 '부분'인지, 어떻게 해야 이러한 부분들이 잘 맞추어질지, 그리고 무엇이 옳은 트레이드 오프인지 고려해야 한다.

대규모 웹 애플리케이션에 필요한 핵심 사항인 `서비스`, `이중화`, `분할`, `예외 처리`에 대한 개념을 정리하기 위해 `이미지 호스팅 애플리케이션`을 예로 시작한다.

# 예: 이미지 호스팅 애플리케이션

수많은 이미지를 관리하고 제공하는 대규모의 사이트는 `효율적인 비용`과 `고가용성`을 만족해야 하고, `적은 레이턴시`(빠른 검색)를 가지는 아키텍처를 구축해야 한다는 도전 과제를 가지고 있다.

사용자는 이미지를 중앙 서버에 업로드할 수 있고, 링크나 API를 통해 요청 받을 수 있는 시스템이 있다고 가정한다.

단순함을 위해 이 애플리케이션에는 두 개의 기능만 있다고 가정한다. 하나는 서버에 이미지를 업로드하는 것(쓰기)이고, 다른 하나는 이미지를 질의하는 것이다.

이미지 업로드가 효율적으로 이루어지고, 동시에 다른 누군가가 이미지 보기를 요청했을 때 매우 빠르게 보여줄 수 있도록 고려해야 한다. (웹 서버나 CDN과 연결된 서버에서 하는 일과 비슷)

> **CDN (Content Distributed Network)**
>
> content를 저장하고 있는 서버를 여러 곳에 위치시켜서 지리적으로나 물리적으로 가장 가까운 사용자에게 빠르게 정보를 전달할 수 있도록 하는 것.

그리고 이 이미지 호스팅 시스템은 다음과 같은 고려해야 할 사항들이 존재한다.

- 저장될 이미지 개수 제한이 없다 => `저장공간의 확장성`에 대해 고려가 필요

* 이미지 보기나 다운로드 요청 시 `응답 시간이 빨라야 한다.`

- 사용자가 이미지 업로드 후 해당 이미지는 시스템에 항상 저장되어 있어야 한다. `(데이터에 대한 신뢰성)`

* 시스템을 운용하기 쉬워야 한다 `(관리성)`

- 서비스 자체의 수익률이 높지 않기 때문에 시스템은 `효율적인 비용`으로 운용될 필요가 있다.

다음은 이미지 호스팅 애플리케이션의 기능을 간단하게 도식화한 것이다.

![image](https://user-images.githubusercontent.com/51476083/119247841-f4825400-bbc7-11eb-8b7a-d0ec49a8d2f4.png)

# 서비스(Services)

확장성 있는 시스템 설계 시 각각의 명확한 인터페이스를 기반으로 기능별로 나누어 생각하는 것은 좋은 방법이다.

이러한 방식으로 설계하는 시스템을 **SOA (Service-Oriented Architecture)** 라고 부른다.

SOA 에서는 명확하게 기능별로 서비스를 구성한다. 그리고 각각의 서비스는 다른 서비스와 상호작용을 위해 다른 서비스에게 공개하는 API 형태인 추상화된 인터페이스를 사용한다.

_시스템을 상호보완적인 서비스로 분할한다는 것은 시스템을 기능 단위로 분리시키는 것을 말한다._

이러한 추상화는 서비스와 서비스가 처한 환경, 그리고 서비스와 서비스 사용자 사이의 명확한 관계를 수립하는 데에 도움이 된다. 이러한 명확한 구분은 문제를 분리시키는 데도 도움이 되지만, 각각을 독립적으로 확장시키는 것에도 효과적이다.

이런 의미에서 시스템에서의 SOA는 객체지향 프로그래밍과 아주 유사하다.

예제 애플리케이션에서 모든 이미지 업로드와 검색을 위한 요청은 같은 서버에서 처리되지만, 시스템을 확장시키기 위해서는 업로드와 검색 기능이 각각의 서비스로 분리되는 것이 합리적이다.

<br/>

이제 서비스가 굉장히 많이 사용되고 있다고 가정한다. 이러한 시나리오는 `쓰기`가 `읽기`에 얼마나 영향을 미치는지 쉽게 확인할 수 있도록 해준다.

왜냐하면 이 두 가지 기능은 공유 자원을 경쟁적으로 사용하고 있기 때문이다. 다운로드와 업로드의 속도가 똑같다고 가정해도(실제로는 다운로드 속도와 업로드 속도의 비율은 3:1 정도이다), `읽기`는 캐시의 도움을 받을 수 있지만 `쓰기` 요청은 결과적으로 디스크까지 도달해야 한다.

심지어 모든 데이터가 메모리나 SSD에 있는 경우에도 데이터베이스 쓰기는 읽기보다 느리다

[(참고) Polepos를 활용한 데이터베이스 성능 비교](http://polepos.sourceforge.net/results/PolePositionClientServer.pdf)

### 문제점

이러한 디자인의 잠재적 문제는 `Apache`나 `lighthttpd` 같은 웹 서버는 동시 커넥션 수에 상한선이 있다는 것이다. (디폴트 값은 대략 500 정도, 더 높게 설정 가능)

읽기는 비동기일 수 있기 때문에 `gzip 압축` 이나 `chunked transfer encoding`을 이용하여 성능을 최적화할 수 있다.

웹 서버의 초당 읽기 요청 처리 수는 보통 최대 커넥션 수보다 많다. 웹 서버는 어느 하나의 읽기 요청을 처리하면 이어서 바로 다른 요청을 처리하기 때문이다. (Apache에서 최대 커넥션 개수가 500으로 설정되어 있을 때 초당 수천 개의 읽기 요청을 처리하는 것은 드문 일이 아니다.)

<br/>

한편 **쓰기의 경우 업로드 동안 연결을 계속 열어 놓은 상태로 유지해야 한다.** 따라서 1MB를 업로드 하는 것이 1초 이상 걸린다면 서버는 고작 500개의 동시적인 쓰기만 처리할 수 있을 뿐이다.

따라서 **병목 현상을 해결하기 위해** 다음의 그림과 같이 읽기와 쓰기를 각각의 서비스로 분리하는 것이 좋은 방법이다.

![image](https://user-images.githubusercontent.com/51476083/119248183-6a87ba80-bbca-11eb-8b2d-dd4e9c470ea6.png)

이 방법은 읽기와 쓰기를 각각 독립적으로 확장할 수 있게 하고, 시스템의 각 부분이 어떻게 돌아가고 있는지 명확히 확인하는 데도 도움이 된다.

이러한 접근법의 장점은 결과적으로 읽기가 느린 현상이 발생할 때의 문제를 해결하고 확장하는 것을 쉽게 한다.

또한 각각의 문제를 독립적으로 해결할 수 있다는 것이다. 같은 서비스 영역에서 쓰기와 조회를 걱정할 필요가 없다.

**요청을 큐로 관리**하거나 **인기 있는 이미지를 캐시에 저장**하는 것과 같은 방식으로 성능을 향상시킬 수도 있다.

유지보수와 비용 관점에서도 각각의 서비스는 필요한 대로 독립적으로 확장이 가능하다. 만약 쓰기와 읽기가 서로 독립적이지 않은 채 서로 결합된 형태라면 어떤 하나가 다른 하나의 성능에 영향을 주게 된다.

당연하게도 이 아키텍처는 서로 다른 두 개의 `endpoint`를 사용해도 잘 동작한다.

> **Endpoint**
>
> 서비스에 접근하는 방법을 의미. 프로토콜 주소 등에 대한 정보를 포함한다.

시스템이 요구하는 것을 결정하고(읽기와 쓰기 중 어떤 것이 많은지, 둘 다 많은지, 질의가 데이터셋 전체에 대한 것인지 부분에 대한 것인지, 정렬은 어떻게 할 것인지 등), 여러 대안을 벤치 마킹하고, 시스템이 어떤 경우에 문제가 발생하는지 이해하고, 그리고 문제가 발생했을 때에 확실한 계획을 가지는 것이 필요하다.

# 이중화(Redundacy)

_장애에 대처하기 위한 웹 아키텍처에는 데이터와 서버에 대한 이중화가 고려되어야 한다._

예를 들어, 한 파일이 어느 한 서버에만 저장되어 있는 상황이라면, 해당 서버에 장애가 발생했을 때 그 파일을 잃어버리게 될 것이다.

데이터를 잃어버리지 않는 가장 보편적인 대처법은 **여러 서버에 데이터를 복제해 두는 것**이다.

같은 원칙이 서비스에도 적용된다. 애플리케이션에 중요한 핵심 기능이 있다면 **같은 기능을 하는 여러 개가 동시에 동작하도록 하는 것**이 필요하다.

시스템을 이중화하는 것은 단일 고장점(Single point of failure)을 없애고, 장애 발생 시에도 백업하게 할 수 있거나 시스템이 계속 동작할 수 있게 한다.

예를 들어, 동일한 서비스를 위해 두 개의 인스턴스가 동작하고 있을 때 하나에 장애가 나면 시스템에서는 문제가 없는 다른 인스턴스만 동작하게 할 수 있다. 이러한 절체 작업은 자동으로 발생하게 할 수도 있고, 운영자의 개입이 필요한 경우도 있다.

서비스를 이중화할 때 중요한 것은 **Shared Nothing 아키텍처를 만드는 것**이다.

이 아키텍처에서는 각각의 노드는 상태나 작업을 관리하는 중앙부 없이 독립적으로 동작 가능하다. 이러한 구조는 시스템이 확장성을 가지고자 할 때 매우 유용하다. 새로운 노드를 특별한 조건이나 지식 없이 추가할 수 있기 때문이다.

그보다 더 중요한 것은 시스템이 단일 고장점을 갖지 않게 된다는 것이다. 따라서 장애에 좀 더 잘 대처할 수 있게 된다.

![image](https://user-images.githubusercontent.com/51476083/119248536-bcc9db00-bbcc-11eb-8061-8994cc710f32.png)

모든 이미지는 각기 다른 하드웨어에 복제 저장이 되며, 요청을 처리하는 동일한 동작을 수행하는 서비스 역시 여러 개가 있을 것이다.

(이러한 것이 가능하기 위해서는 로드 밸런서가 필요하다)

# 파티션(Partitions)

하나의 서버에서 감당할 수 없는 많은 데이터가 있을 수 있다. 또는 연산을 위해 많은 컴퓨팅 자원이 필요하게 되어 성능이 떨어지게 되는 경우가 있을 수 있다.

이러한 문제를 해결하기 위해서는 두 가지 선택이 있다.

**1. 수직적 확장**

> 각 자원의 처리 능력을 향상시키는 것

- 개개의 서버에 더 많은 자원을 추가하는 것을 의미한다.

* 많은 데이터를 처리하기 위해 서버에 디스크 용량을 늘리거나 더 빠른 계산 성능을 위해 더 빠른 CPU나 큰 용량의 메모리를 추가하는 방법이 이에 해당한다.

2. 수평적 확장

> 노드를 추가하는 것

- 데이터가 많을 경우 부분 데이터를 저장할 수 있는 노드를 추가하는 것이다.

* 많은 연산을 필요로 하는 경우 연산을 분리하여, 추가한 노드에서 작업이 이루어지도록 한다.

- 시스템 아키텍처의 고유한 설계 원칙들을 따라야 한다.

  - 그렇지 않으면 기능 단위를 수정하거나 분리하는 것이 굉장히 불편한 일이 되어 버릴 수도 있다.

* **가장 보편적인 방법은 서비스를 `파티션`이나 `샤드` 단위로 분할하는 것이다.**

  - 파티션은 기능별 논리 집합으로 분산될 수 있다. <br/>

  - 이러한 파티션은 특정 사용자나 데이터의 지리적 위치에 따라 만들어질 수 있고, 혹은 무료 사용자/유료 사용자 같은 기준에 따라 만들어질 수도 있다. <br/>

  - 이러한 형태의 장점은 증설한 것을 바탕으로 서비스나 데이터 저장소를 제공할 수 있다는 것이다.

<br/>

이미지 서버 예제 아키텍처에서는 이미지를 저장하기 위해 사용하는 하나의 파일 서버를 여러 개의 파일 서버로 대체할 수 있다. 그리고 그 서버마다 처리하는 이미지들이 다르다.

![image](https://user-images.githubusercontent.com/51476083/119248956-d28ccf80-bbcf-11eb-81bf-7d90f2a99621.png)

=> `이중화`와 `수평 확장`이 고려된 이미지 호스팅 애플리케이션

이런 아키텍처에서는 디스크가 가득 차는 상황이 발생할 때 다른 서버에 파일을 저장할 수 있게 한다.

이 설계에서는 이미지의 이름을 바탕으로 해당 이미지가 저장되어 있는 서버를 찾을 수 있는 방법이 필요하다.

이미지의 이름은 서버를 가리킬 수 있는 `Consistent Hashing` 형태일 수도 있다. 혹은 이미지의 이름은 증가되는 ID가 될 수 있으며, 이 경우에는 이미지 조회 서비스는 각 서버에 저장되어 있는 ID 범위만 알고 있으면 된다.(인덱스와 비슷하다)

물론 여러 서버에 데이터나 기능을 분산시키는 것에는 기술적인 도전이 있다.

**1. Data locality**

연산하려는 데이터가 가까이 위치해 있을수록 시스템의 성능이 향상된다.

따라서 필요한 데이터를 여러 서버에 분산시키는 것은 로컬에 있지 않을 수 있는 데이터를 얻기 위해 비용이 높은 네트워크를 이용한 읽기가 발생할 수있어 잠재적인성능 문제가 발생할 수 있다.

**2. Inconsistency**

공유된 자원으로부터 읽기와 쓰기를 하는 서로 다른 서비스가 있다고 가정한다.

여기서는 `race condition`이 발생할 가능성이 있다. 어떠한 데이터가 업데이트되려 할 때, 읽기 요청이 업데이트 요청보다 먼저 발생했다면 해당 데이터는 `inconsistency` 상태가 된다.

예를 들어 어떤 클라이언트가 어떤 이미지 이름을 변경하는 업데이트 요청을 보냈고, 동시에 다른 클라이언트가 해당 이미지를 읽고 있다면 `Race condition`이 발생한다. => **두 번째 사용자가 받아야하는 이미지의 이름이 불명확하다.**

데이터를 파티셔닝 하는 것에는 난관이 있지만, 파티셔닝은 각각의 문제(데이터, 로드, 사용 패턴 등)를 관리할 수 있는 작은 단위로 분리시킬 수 있게 한다. 이러한 점은 확장성과 관리성에 도움을 주지만 위험이 없지는 않다.

이러한 위험 요소를 줄이고 장애를 해결하는 많은 방법이 있다. [Fault tolerance & Monitoring](https://katemats.com/blog/distributed-systems-basics-handling-failure-fault-tolerance-and-monitoring/)

## 참고

[Scalable Web Architecture And Distributed Systems](http://www.aosabook.org/en/distsys.html)
