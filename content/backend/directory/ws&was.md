---
title: '웹 서버와 WAS'
metaTitle: '만렙 개발자 키우기'
metaDescription: '웹 애플리케이션 컨테이너를 정리하였습니다.'
tags: ['Backend']
date: '2021-03-15'
---

# 웹 애플리케이션 컨테이너

웹 애플리케이션이 배포되는 공간

### 웹 서버

HTML 같은 정적 파일들을 전달해주는 역할을 하는 서버

웹 브라우저 클라이언트로부터 HTTP 요청을 받고, 정적인 컨텐츠(html, css)를 제공하는 컴퓨터 프로그램 (Apache, Nginx)

#### 웹 서버가 필요한 이유

웹 문서가 클라이언트로 전송될 때, 이미지 파일과 같은 정적인 컨텐츠는 함께 보내지지 않는다.

먼저 HTML 문서를 받고, 필요한 이미지 파일들을 다시 서버로 요청해서 받아온다.

이 때, 웹 서버를 통해 정적인 파일을 애플리케이션 서버까지 가지 않고 앞단에서 빠르게 받아올 수 있다.

<hr/>

### 웹 애플리케이션 서버

DB 조회 및 다양한 로직 처리 요구 시 동적인 컨텐츠를 제공하기 위해 만들어진 애플리케이션 서버. => `웹 서버 + 웹 컨테이너`

Tomcat, JBoss 등이 있다.

`WAS (Web Applicaiton Server)` 라고도 부른다.

PHP, ASP, JSP 같은 언어들을 사용해서 동적인 페이지들을 생성할 수 있는 서버 (= 웹 애플리케이션 컨테이너)

WAS 가 웹 애플리케이션을 인식하고 동작시키는 방법을 알기 위해선 클래스 로더를 알아야한다.

웹 애플리케이션 자체 API를 제공하기 위해 컨테이너를 로드하는 `클래스 로더` 와 사용자가 추가한 JSP 나 WAR 파일들을 다루기 위한 `ServletContext Loader`를 사용한다.

#### 웹 애플리케이션 서버가 필요한 이유

웹 서버 만으로는 사용자가 원하는 요청에 대한 결과를 모두 만들어 놓고 서비스하기에는 자원이 절대적으로 부족하다.

따라서 WAS를 통해 사용자의 요청에 따라 동적인 컨텐츠를 그때마다 만들어서 제공함으로써 자원을 효율적으로 사용할 수 있다.

<hr/>

### 그럼 WAS로 웹 서버 역할도 처리할 수 있지 않나?

WAS가 정적 컨텐츠 요청까지 처리하면, 서버에 부하가 너무 커지고 동적 컨텐츠 처리가 지연되면서 수행 속도가 느려지게 된다.

그러면 페이지 노출 시간이 늘어나는 문제가 발생한다.

따라서 웹 서버는 정적 콘텐츠 생성에 집중하고, WAS는 동적 컨텐츠 생성에 집중해서 서로 기능을 분리시킴으로써 서버의 부하를 줄일 수 있다.

### 둘을 구분 하는 이유

웹 서버에서는 정적 컨텐츠만 처리하고, WAS에서는 동적 컨텐츠를 처리함으로써 기능을 분배하고 서버 부담을 줄일 수 있다.

즉 자원 이용의 효율성 및 장애 극복, 배포 및 유지 보수의 편의성 때문에 웹 서버와 WAS를 분리해 사용한다.

<hr/>

### 가장 효율적인 방법

웹 서버를 WAS 앞에 두고, 필요한 WAS 들을 웹 서버에 플러그인 형태로 설정하면 효율적인 분산 처리가 가능하다.

![image](https://user-images.githubusercontent.com/51476083/113153295-e708b780-9271-11eb-96fe-c178d1ca37c3.png)

1. 클라이언트의 요청을 먼저 웹 서버가 받은 다음, WAS에게 보내 관련된 Servlet을 메모리에 올린다.

2) WAS는 `web.xml`을 참조해 해당 Servlet에 대한 스레드를 생성한다. (스레드 풀 이용)

3. 이때 `HttpServletRequest`와 `HttpServletResponse` 객체를 생성해 Servlet에게 전달한다.

4) `doGet()`이나 `doPost()` 메소드는 인자에 맞게 생성된 적절한 동적 페이지를 `Response` 객체에 담아 WAS에 전달한다.

5. WAS는 `Response` 객체를 `HttpResponse` 형태로 바꿔 웹 서버로 전달한다.

6) 생성된 스레드 종료하고, `HttpServletRequest`와 `HttpServletResponse` 객체를 제거한다.

<hr/>

### 클래스 로더

자바 코드 작성 후, 컴파일하면 해당 코드는 JVM 에서 실행 가능한 상태가 된다.

이때 JVM 이 클래스를 실행하기 위해서는 클래스를 로딩하는 과정이 필요하다. 그 과정을 수행해주는 역할을 한다.

클래스패스에 모듈 or 라이브러리를 추가하면 클래스 로더는 식별자로 클래스 메타 정보 중 첫 번째 시작 필드를 이용해 클래스를 로딩한다.

#### 특징

- 구조가 계층적이다

  - 상위 클래스 로더에서 하위 클래스 로더를 갖는 방식

  - 최상위 클래스 로더는 부트스트랩 클래스 로더이다

* 클래스 로딩 위임 가능

- 가시적인 규약이 있다

  - 가시적인 규약 : 클래스를 로딩할 때 가능한 범위

  - 자식 클래스 로더는 클래스 로딩 요청 위임을 통해 부모 클래스 로더가 로딩한 클래스를 찾을 수 있지만, 부모 클래스 로더는 자식 클래스 로더가 로딩한 클래스를 알 수 없다.

* 클래스 언로딩이 불가능

  - 클래스 로더가 로딩한 클래스를 언로드할 수 없으므로 가비지 컬렉터가 동작하거나 WAS 재 시작시 초기화.

#### 유형

1. Bootstrap Class Loader

   JVM 런타임 실행을 위해 기반이 되는 파일들을 로드. `rt.jar` 파일과 연관

2) Extension Class Loader

   자바 최상위 객체인 `Object` 를 포함한 자바 API 를 로드

3. System Class Loader

   클래스 패스에 포함된 클래스들을 로드.

   클래스 패스 : 사용자가 접근할 수 있는 영역. 로컬에서 외부 라이브러리 실행 시 클래스 패스를 지정해서 실행하기도 한다.

4) User-Defined Class Loader

<hr/>

### WAR 파일

`Web Application Archive` 또는 `Web Application Resource` 를 뜻한다

압축 파일에 자바 관련 규약이 포함된 것 => `WEB-INF`

웹 개발 시 결과물이 되는 형식

`WAS` 는 WAR 파일의 WEB-INF 폴더를 기준으로 클래스 파일들을 로드

#### 배포

- 로컬 실행 프로그램은 `JAR` 로 패키징

  (Gradle 을 통해 빌드 시 `build.gradle` 파일에 Jar 파일 추가해서 사용 가능)

* 웹은 `WAR` 로 패키징

      Web Archive
      |
      |--- WEB-INF
           |
           |-- content directory  : .html, .js, .css 파일
           |
           |-- classes : .java 파일
           |
           |-- libs : .jar 파일 (외부 라이브러리 파일) 사용자 정의 클래스 로더
                                (애플리케이션 로더를 통해 클래스 패스에 추가됨)

<hr/>

### 웹 애플리케이션 클래스 로더

클래스 로더 유형 중 시스템 클래스 로더 하위에 사용자가 정의한 클래스 로더

```java
 System Class Loader
        ⬆
  ServletContainer
        ⬆
  ServletContext
```

```java
  |-----------|  |-----------|
  |  Classes  |  |           |
  |-----------|  |  Servlet  |
  | Libraries |  |           |
  |-----------|  |-----------|

  |--------------------------|
  |     WebAppClassLoader    |
  |--------------------------|
```

컨테이너가 시작되고 컨텍스트가 초기화되면 서블릿 스펙의 권장 사항에 따라 `WEB-INF/classes` 파일을 먼저 검색해서 로딩하고,

그 후에 `WEB-INF/libs` 에 있는 JAR 파일들을 로드한다.
