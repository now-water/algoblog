## 페치 조인
객체 그래프를 조회하는 것 - 연관된 엔티티들도 `JOIN` 을 통해 한번에 조회하는 기능

즉, 엔티티를 `SELECT` 하는 경우에만 사용할 수 있다.

### 사용 불가능한 경우

- 데이터를 하나씩 찍어서 조회하는 경우


- DTO 로 직접 조회하는 경우

    `SELECT new *.*Dto(생성자에 들어갈 매개변수) FROM ~~`  컬렉션은 DTO로 바로 조회가 불가능해서 DTO 리스트를 만든 후, 다시 컬렉션 필드를 조회하는 쿼리로 불러와서 `setter` 사용

<hr/>

## 컬렉션 페치

**1:N 조인**
: fetch 조인을 하면 조회되는 row 수가 증가한다. N 쪽을 기준으로 모든 데이터가 조회되버리기 때문이다

`ex) Order(1) 와 OrderItem(N) 을 페치조인할 경우` Order를 조회하려고 해도 OrderItem을 기준으로 row가 조회되버림

`distinct` 키워드를 사용해 같은 엔티티 조회 시 어플리케이션에서 중복을 걸러준다

1:N 조인에서는

 1. **컬렉션 페치 조인을 1개만 사용해야한다.**
    <br/>
    안그러면 1:N: 복잡해져서 데이터가 부정합하게 조회됨.

<br/>

 2. **컬렉션 페치는 페이징이 불가능하다.**
    <br/>
    페이징 시 메모리에 로딩해서 페이징해버려서 메모리가 터져버린다.

<hr/>

## 한계 돌파

페이징 + 컬렉션 엔티티 조회를 할 수 있는 방법이 존재한다.
`N + 1` 문제를 `1 + 1` 로 최적화 가능

1. `ToOne` (OneToOne, ManyToOne) 관계를 모두 페치조인 한다. <br/>
  `ToOne` 관계는 `row` 수를 증가시키지 않으므로 페이징 쿼리에 영향을 안준다.


2. 컬렉션은 지연 로딩으로 조회한다.


3. 지연 로딩 성능 최적화를 위해 `hibernate.default_batch_fetch_size` , `@BatchSize`를 적용한다. <br/>
- `hibernate.default_batch_fetch_size` : 글로벌 설정.  주로 사용하는 방법


- `@BatchSize` : 개별 최적화(직접 엔티티나 필드에 설정해줌 - 그때 그때 달라서 잘 안쓰임)


- 이 옵션을 사용하면 컬렉션이나, 프록시 객체를 한꺼번에 설정한 `size` 만큼 `IN 쿼리`로 조회한다.


## 결론

`ToOne` 관계는 페치조인해서 쿼리수 줄인다. 페이징에 영향 x,


나머지는 `hibernate.default_batch_fetch_size` 로 최적화한다. 보통 100~1000 사이를 선택. 순간 부하를 견딜 수 있을정도로 결정


100으로 하든 1000으로 하든 어플리케이션은 전체 데이터를 로딩해야 하므로 메모리 사용량이 같다.


