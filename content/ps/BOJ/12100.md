---
title: '12100. 2048(easy)'
metaTitle: 'ë§Œë ™ ê°œë°œì í‚¤ìš°ê¸°'
metaDescription: 'ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œë¥¼ í’€ê³  ì •ë¦¬í•œ ê³³ì…ë‹ˆë‹¤.'
tags: ['êµ¬í˜„', 'ë¸Œë£¨íŠ¸í¬ìŠ¤', 'ì‹œë®¬ë ˆì´ì…˜']
date: '2021-01-17'
---

# ë¬¸ì œ

- [12100. 2048(easy)](https://www.acmicpc.net/problem/12100)

## ì½”ë“œ

<details><summary> ì½”ë“œ ë³´ê¸° </summary>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Pair{
    int x, y;
    public Pair(int x, int y){
        this.x = x;
        this.y = y;
    }
}

class Snap{
    int snapshot[][];

    public Snap(int n){
        this.snapshot = new int[n][n];
    }
    public Snap(int[][] snapshot) {
        this.snapshot = snapshot;
    }
}

public class Q12100 {
    static int n, board[][], max = 0, dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};
    static Snap start;

    public static void main(String[] args) throws IOException {
        init();
        solution();
    }

    static void init() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        n = Integer.parseInt(br.readLine());
        board = new int[n][n];
        for (int i = 0; i < n; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < n; j++)
                board[i][j] = Integer.parseInt(st.nextToken());
        }
        start = new Snap(board);
    }

    static void solution() {
        Queue<Snap> q = new LinkedList<>();
        q.add(start);

        int size, round = 0;
        while(!q.isEmpty()){
            if(round >= 5) break;
            size = q.size();
            for (int i = 0; i < size; i++) {
                Snap now = q.poll();
                for (int j = 0; j < 4; j++) {
                    Snap temp = new Snap(n);
                    copyArr(temp.snapshot, now.snapshot);
                    move(temp.snapshot, j);
                    updateMax(temp.snapshot);
                    q.add(temp);
                }
            }
            round += 1;
        }
        System.out.println(max);
    }

    static void move(int snapshot[][], int dir) {
        boolean merge[][] = new boolean[n][n];
        for (int i = 0; i < n; i++)
            Arrays.fill(merge[i], false);

        if(dir == 0){ // up
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if(snapshot[i][j] == 0) continue;
                    int x = i, y = j;
                    while(true){
                        int nx = x + dx[dir], ny = y + dy[dir];
                        if(!isBorder(nx, ny)) break;
                        if(snapshot[nx][ny] == 0)
                        {
                            snapshot[nx][ny] = snapshot[x][y];
                            snapshot[x][y] = 0;
                        }
                        else
                        {
                            if(snapshot[nx][ny] == snapshot[x][y] && !merge[nx][ny]) {
                                snapshot[nx][ny] = 2 * snapshot[x][y];
                                snapshot[x][y] = 0;
                                merge[nx][ny] = true;
                            }
                            break;
                        }
                        x = nx; y = ny;
                    }
                }
            }
        } else if(dir == 1){ // right
            for (int i = 0; i < n; i++) { // row
                for (int j = n - 1; j >= 0; j--) { // col
                    if(snapshot[i][j] == 0) continue;
                    int x = i, y = j;
                    while(isBorder(x, y)){
                        int nx = x + dx[dir], ny = y + dy[dir];
                        if(!isBorder(nx, ny)) break;
                        if(snapshot[nx][ny] == 0)
                        {
                            snapshot[nx][ny] = snapshot[x][y];
                            snapshot[x][y] = 0;
                        }
                        else
                        {
                            if(snapshot[nx][ny] == snapshot[x][y] && !merge[nx][ny]) {
                                snapshot[nx][ny] = 2 * snapshot[x][y];
                                snapshot[x][y] = 0;
                                merge[nx][ny] = true;
                            }
                            break;
                        }
                        x = nx; y = ny;
                    }
                }
            }
        } else if(dir == 2){ // down
            for (int i = n - 1; i >= 0; i--) {
                for (int j = 0; j < n; j++) {
                    if(snapshot[i][j] == 0) continue;
                    int x = i, y = j;
                    while(isBorder(x, y)){
                        int nx = x + dx[dir], ny = y + dy[dir];
                        if(!isBorder(nx, ny)) break;
                        if(snapshot[nx][ny] == 0)
                        {
                            snapshot[nx][ny] = snapshot[x][y];
                            snapshot[x][y] = 0;
                        }
                        else
                        {
                            if(snapshot[nx][ny] == snapshot[x][y] && !merge[nx][ny]) {
                                snapshot[nx][ny] = 2 * snapshot[x][y];
                                snapshot[x][y] = 0;
                                merge[nx][ny] = true;
                            }
                            break;
                        }
                        x = nx; y = ny;
                    }
                }
            }
        } else { // left
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if(snapshot[i][j] == 0) continue;
                    int x = i, y = j;
                    while(isBorder(x, y)){
                        int nx = x + dx[dir], ny = y + dy[dir];
                        if(!isBorder(nx, ny)) break;
                        if(snapshot[nx][ny] == 0)
                        {
                            snapshot[nx][ny] = snapshot[x][y];
                            snapshot[x][y] = 0;
                        }
                        else
                        {
                            if(snapshot[nx][ny] == snapshot[x][y] && !merge[nx][ny]) {
                                snapshot[nx][ny] = 2 * snapshot[x][y];
                                snapshot[x][y] = 0;
                                merge[nx][ny] = true;
                            }
                            break;
                        }
                        x = nx; y = ny;
                    }
                }
            }
        }
    }

    private static boolean isBorder(int x, int y) {
        return (x >= 0 && x < n && y >= 0 && y < n);
    }

    static void copyArr(int[][] snap, int[][] snapshot) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                snap[i][j] = snapshot[i][j];
            }
        }
    }
    static void updateMax(int[][] snap) {
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                if(snap[i][j] > max) max = snap[i][j];
    }
}
/*
Queue ë¥¼ ì´ìš©í•´ í‘¸ëŠ” ë°©ë²•

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine());
		int[][] arr = new int[N][N];

		for(int i = 0; i < N; i++) {
			StringTokenizer st = new StringTokenizer(br.readLine());

			int count = st.countTokens();

			for(int j = 0; j < count; j++)
				arr[i][j] = Integer.parseInt(st.nextToken());
		}

		System.out.println(dfs(arr, 0));

		br.close();
	}

	public static int dfs(int[][] arr, int depth) {
		if(depth == 5) {
			return maxNum(arr);
		}

		int[][] temp = copy(arr);
		int[] maxArr = new int[4];

		left(temp);
		maxArr[0] = dfs(temp, depth + 1);

		temp = copy(arr);
		right(temp);
		maxArr[1] = dfs(temp, depth + 1);

		temp = copy(arr);
		up(temp);
		maxArr[2] = dfs(temp, depth + 1);

		temp = copy(arr);
		down(temp);
		maxArr[3] = dfs(temp, depth + 1);

		int max = Integer.MIN_VALUE;

		for(int i = 0; i < maxArr.length; i++) {
			if(maxArr[i] > max)
				max = maxArr[i];
		}

		return max;
	}

	public static int[][] copy(int[][] arr) {
		int[][] copy = new int[arr.length][arr.length];

		for(int i = 0; i < arr.length; i++) {
			for(int j = 0; j < arr[i].length; j++) {
				copy[i][j] = arr[i][j];
			}
		}

		return copy;
	}

	public static int maxNum(int[][] arr) {
		int max = Integer.MIN_VALUE;

		for(int i = 0; i < arr.length; i++) {
			for(int j = 0; j < arr[i].length; j++) {
				if(arr[i][j] > max)
					max = arr[i][j];
			}
		}

		return max;
	}

	public static void left(int[][] arr) {
		for(int i = 0; i < arr.length; i++) {
			Queue<Integer> q = new LinkedList<>();
			for(int j = 0; j < arr[i].length; j++) {
				if(arr[i][j] != 0) {
					q.add(arr[i][j]);
					arr[i][j] = 0;
				}
			}

			int index = 0;
			while(!q.isEmpty()) {
				int value = q.poll();

				if(!q.isEmpty() && value == q.peek()) {
					value += q.poll();
					arr[i][index++] = value;
				} else {
					arr[i][index++] = value;
				}
			}
		}
	}

	public static void right(int[][] arr) {
		for(int i = 0; i < arr.length; i++) {
			Queue<Integer> q = new LinkedList<>();
			for(int j = arr.length - 1; j > -1; j--) {
				if(arr[i][j] != 0) {
					q.add(arr[i][j]);
					arr[i][j] = 0;
				}
			}

			int index = arr.length - 1;
			while(!q.isEmpty()) {
				int value = q.poll();

				if(!q.isEmpty() && value == q.peek()) {
					value += q.poll();
					arr[i][index--] = value;
				} else {
					arr[i][index--] = value;
				}
			}
		}
	}

	public static void up(int[][] arr) {
		for(int i = 0; i < arr.length; i++) {
			Queue<Integer> q = new LinkedList<>();
			for(int j = 0; j < arr[i].length; j++) {
				if(arr[j][i] != 0) {
					q.add(arr[j][i]);
					arr[j][i] = 0;
				}
			}

			int index = 0;
			while(!q.isEmpty()) {
				int value = q.poll();

				if(!q.isEmpty() && value == q.peek()) {
					value += q.poll();
					arr[index++][i] = value;
				} else {
					arr[index++][i] = value;
				}
			}
		}
	}

	public static void down(int[][] arr) {
		for(int i = 0; i < arr.length; i++) {
			Queue<Integer> q = new LinkedList<>();
			for(int j = arr.length - 1; j > -1; j--) {
				if(arr[j][i] != 0) {
					q.add(arr[j][i]);
					arr[j][i] = 0;
				}
			}

			int index = arr.length - 1;
			while(!q.isEmpty()) {
				int value = q.poll();

				if(!q.isEmpty() && value == q.peek()) {
					value += q.poll();
					arr[index--][i] = value;
				} else {
					arr[index--][i] = value;
				}
			}
		}
	}
}

 */
```

</details>

## â­ï¸ëŠë‚€ì â­ï¸

> ì—¬íƒœ í’€ì–´ë³¸ êµ¬í˜„ì¤‘ì— ì†ê¼½ì•„ ì–´ë ¤ìš´ ë¬¸ì œì˜€ë‹¤. ì´ì „ì— í’€ì—ˆë˜ êµ¬ìŠ¬ íƒˆì¶œê³¼ ë¹„ìŠ·í•˜ê²Œ í’€ì–´ë³´ë ¤ê³  í–ˆì§€ë§Œ ë” ë³µì¡í–ˆë‹¤.. ì´í‹€ë™ì•ˆ ë©”ë‹¬ë ¤ì„œ í‘¼ ë¬¸ì œ <br/>

> ìë°”ëŠ” ì™œ ê¸°ë³¸ ìë£Œí˜• ì™¸ì—ëŠ” ì „ë¶€ ê°’ì´ ë³µì‚¬ë˜ëŠ” ê²ƒì¸ê°€................... <br/>

> ì¡°ê¸ˆ ë°˜ë³µì ì¸ ì½”ë“œê°€ ì¡´ì¬í•˜ë”ë¼ë„, í™•ì‹¤í•˜ê²Œ ë©”ì„œë“œë¥¼ ìš©ë„ì— ë”°ë¼ êµ¬ë¶„í•´ì„œ ì‘ì„±í•˜ëŠ” ë°©ë²•ë„ ê³ ë ¤í•´ì•¼ê² ë‹¤.

## í’€ì´ ğŸ“£

<hr/>
1ï¸âƒ£ ìƒ.í•˜.ì¢Œ.ìš° ë°©í–¥ìœ¼ë¡œ í˜„ì¬ ìƒíƒœì—ì„œ ëª¨ë‘ ì´ë™ì‹œí‚¨ë‹¤. ì´ ë•Œ, ê° ë°©í–¥ì— ìˆì–´ ë¨¼ì € ê°€ì¥ìë¦¬ì— ë„ì°©í•˜ëŠ” ì¹¸ë¶€í„° ë™ì‘ì„ ìˆ˜í–‰í•œë‹¤. <br/>

2ï¸âƒ£ ê°™ì€ ìˆ«ìë¥¼ ë§Œë‚˜ê²Œ ë˜ë©´ í•´ë‹¹ ì¹¸ì—ì„œ ì´ë¯¸ í•©ì³ì§„ ìˆ«ìê°€ ì—†ì„ ê²½ìš°ì— \*2 ë¥¼ ìˆ˜í–‰í•œë‹¤. <br/>

3ï¸âƒ£ ìœ„ì˜ ê³¼ì •ì„ 5ë²ˆ ë°˜ë³µí•´ì„œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê°€ì¥ ë†’ì€ ìˆ«ìë¥¼ ì¶œë ¥í•œë‹¤. <br/>

<hr/>

## ì‹¤ìˆ˜ ğŸ˜…

- ìë°”ì˜ ê°’ ë³µì‚¬ê°€ C++ê³¼ëŠ” ë§¤ìš° ë‹¤ë¥´ë‹¤.. Snap tempë¥¼ ì–´ë””ì„œ ì„ ì–¸í•´ì£¼ëƒì— ë”°ë¼ì„œ ê°’ì´ ì´ìƒí•˜ê²Œ ë³µì‚¬ë˜ì„œ ê³„ì† í—¤ë§¸ë‹¤.
- ë‚˜ë¦„ ì½”ë“œì˜ ê°„ê²°ì„±ì„ ìœ„í•´ì„œ í•˜ë“œì½”ë”©ë§ê³  dirì— ë”°ë¼ì„œ ì—°ì‚°í•˜ëŠ” ë¶€ë¶„ì„ í•˜ë‚˜ì˜ ë©”ì„œë“œë¡œ ì§œë ¤ë‹¤ê°€ êµ‰ì¥íˆ ë³µì¡í•´ì¡Œë‹¤. ì´ëŸ° BFS ë¬¸ì œì—ì„œëŠ” ê·¸ëƒ¥ ìƒí•˜ì¢Œìš°ë¥¼ ê° ë©”ì„œë“œë¡œ ë‚˜ëˆ ì„œ ì§œì•¼ê² ë‹¤.
