---
title: '2186. ë¬¸ìíŒ'
metaTitle: 'ë§Œë ™ ê°œë°œì í‚¤ìš°ê¸°'
metaDescription: 'ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œë¥¼ í’€ê³  ì •ë¦¬í•œ ê³³ì…ë‹ˆë‹¤.'
tags: ['DP', 'ê·¸ë˜í”„ ì´ë¡ ', 'ê·¸ë˜í”„ íƒìƒ‰']
date: '2021-01-23'
---

# ë¬¸ì œ

- [2186. ë¬¸ìíŒ](https://www.acmicpc.net/problem/2186)

## ì½”ë“œ

<details><summary> ì½”ë“œ ë³´ê¸° </summary>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Q2186 {
    static int n, m, k, ans, dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};
    static char board[][] = new char[101][101];
    static String word;
    static int cache[][][] = new int [81][101][101];
    static boolean visited[][][] = new boolean[10][101][101];
    public static void main(String[] args) throws IOException {
        init();
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                if(word.charAt(0) == board[i][j])
                    ans += solution(i, j, 1);
        System.out.println(ans);
    }

    private static int solution(int x, int y, int cnt) {
        if(cache[cnt][x][y] > -1) return cache[cnt][x][y];
        if(cnt >= word.length()) return 1;
        int res = 0;

        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i], ny = y + dy[i], count = 1;
            while(isBorder(nx, ny) && count <= k){
                if(board[nx][ny] == word.charAt(cnt))
                    res += solution(nx, ny, cnt + 1);

                nx += dx[i]; ny += dy[i];
                count += 1;
            }
        }
        return cache[cnt][x][y] = res;
    }

    private static boolean isBorder(int x, int y) {
        return (x >= 0 && x < n && y >= 0 && y < m);
    }

    private static void init() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        k = Integer.parseInt(st.nextToken());

        for (int i = 0; i < n; i++) {
            String line = br.readLine();
            for (int j = 0; j < m; j++)
                board[i][j] = line.charAt(j);
        }
        word = br.readLine();
        for (int i = 0; i <= word.length(); i++)
            for (int j = 0; j < n; j++)
                Arrays.fill(cache[i][j] , -1);
    }
}

```

</details>

## â­ï¸ëŠë‚€ì â­ï¸

> ALGOSPOT ì˜ BOGGLE ë¬¸ì œì™€ ë¹„ìŠ·í•œ í’€ì´ë¡œ ì‰½ê²Œ í’€ì–´ëƒˆë‹¤. ë¬¸ì œë¥¼ ì—¬ëŸ¬ê°œ í’€ë‹¤ë³´ë‹ˆ ë¬¸ì œí’€ì´ê°€ ì¡°ê¸ˆì”© ê²¹ì¹˜ëŠ”ê²ƒì„ ì•„ì£¼ ì¡°ê¸ˆì´ë‚˜ë§ˆ ëŠë¼ê¸° ì‹œì‘í–ˆë‹¤.

## í’€ì´ ğŸ“£

<hr/>

1ï¸âƒ£ `n * m` ë°°ì—´ì—ì„œ ë‹¨ì–´ì˜ ì‹œì‘ ë¬¸ìì™€ ì¼ì¹˜í•˜ëŠ” ì¹¸ì—ì„œ íƒìƒ‰ì„ ì‹œì‘í•œë‹¤.

2ï¸âƒ£ 3ì°¨ì› ìºì‹œë°°ì—´ì„ ë§Œë“¤ì–´ `cache[í˜„ì¬ ë‹¨ì–´ì˜ ëª‡ ë²ˆì§¸ ìë¦¬ì¸ì§€][í˜„ì¬ x ì¢Œí‘œ][í˜„ì¬ y ì¢Œí‘œ]`ì— `í˜„ì¬ ìœ„ì¹˜ì—ì„œ ì´ë™ ê°€ëŠ¥í•œ ëª¨ë“  ë°©í–¥ìœ¼ë¡œ íƒìƒ‰í•´ì„œ ë‹¨ì–´ë¥¼ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê²½ìš°ì˜ ìˆ˜`ë¥¼ ì €ì¥í•˜ê³  ì´í›„ ì¬ì‚¬ìš©í•œë‹¤.

3ï¸âƒ£ 4ê°€ì§€ ë°©í–¥ìœ¼ë¡œ k ì¹¸ ë§Œí¼ ì´ë™í•  ìˆ˜ ìˆì§€ë§Œ, ì´ë™ì„ í•˜ë ¤ë©´ ë‹¤ìŒ ì¸ë±ìŠ¤ì˜ ê°’ì´ ë‹¨ì–´ì˜ cnt ìë¦¬ê°’ê³¼ ê°™ì•„ì•¼ ì´ë™í•  ìˆ˜ ìˆë‹¤.

    while(isBorder(nx, ny) && count <= k){
                if(board[nx][ny] == word.charAt(cnt))
        ...
    }

4ï¸âƒ£ ëª¨ë“  ê°€ëŠ¥í•œ ê²½ìš°ì˜ ìˆ˜ë¥¼ ëª¨ë‘ ë”í•´ì„œ ê°’ì„ ì¶œë ¥í•œë‹¤.

<hr/>
