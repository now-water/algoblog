---
title: '2042. êµ¬ê°„ í•© êµ¬í•˜ê¸°'
metaTitle: 'ë§Œë ™ ê°œë°œì í‚¤ìš°ê¸°'
metaDescription: 'ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œë¥¼ í’€ê³  ì •ë¦¬í•œ ê³³ì…ë‹ˆë‹¤.'
tags: ['ìë£Œ êµ¬ì¡°', 'ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬']
date: '2021-01-28'
---

# ë¬¸ì œ

- [2042.êµ¬ê°„ í•© êµ¬í•˜ê¸°](https://www.acmicpc.net/problem/2042)

## ì½”ë“œ

<details><summary> ì½”ë“œ ë³´ê¸° </summary>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Q2042 {
    static int n, m, k;
    static long seg[], arr[];

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        k = Integer.parseInt(st.nextToken());
        arr = new long[n + 1];
        seg = new long[4 * n + 1];
        for (int i = 1; i <= n; i++)
            arr[i] = Long.parseLong(br.readLine());

        // making segment tree
        makeSegment(1, n, 1);

        // input commands
        for (int i = 0; i < m + k; i++) {
            st = new StringTokenizer(br.readLine());
            long com = Long.parseLong(st.nextToken()), s = Long.parseLong(st.nextToken()), e = Long.parseLong(st.nextToken());
            if(com == 1) {
                changeNode((int)s, 1, n, 1, e - arr[(int)s]);
                arr[(int)s] = e;
            }
            else
                System.out.println(segSum((int)s, (int)e, 1, n, 1));
        }
    }

    private static long makeSegment(int s, int e, int node) {
        if (s == e) return seg[node] = arr[s];
        int mid = (s + e) / 2;
        return seg[node] = makeSegment(s, mid, node * 2) + makeSegment(mid + 1, e, node * 2 + 1);
    }

    static long segSum(int left, int right, int start, int end, int node) {
        if (end < left || start > right) return 0;
        if (left <= start && end <= right)
            return seg[node];
        int mid = (start + end) / 2;
        return segSum(left, right, start, mid, node * 2) + segSum(left, right, mid + 1, end, node * 2 + 1);
    }

    static void changeNode(int idx, int start, int end, int node, long value) {
        if(start > idx || end < idx) return;
        seg[node] += value; // value is difference with original element.
        if(start != end) {
            int mid = (start + end) / 2;
            changeNode(idx, start, mid, node * 2, value);
            changeNode(idx, mid + 1, end, node * 2 + 1, value);
        }
    }
}
```

</details>

## â­ï¸ëŠë‚€ì â­ï¸

> ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ë¥¼ í™œìš©í•´ì„œ êµ¬ê°„ í•©ì„ êµ¬í•˜ëŠ” ê²ƒì€ ìì£¼ ì‚¬ìš©ëœë‹¤ê³  í•˜ë‹ˆ ê¹Œë¨¹ì§€ ë§ì•„ì•¼ê² ë‹¤. ì–´ë µì§„ ì•Šì§€ë§Œ ì˜¤ëœë§Œì— ë³´ë©´ ë°”ë¡œ êµ¬í˜„ì„ í•˜ê¸° ì¡°ê¸ˆ ê¹Œë‹¤ë¡œìš¸ ìˆ˜ ìˆê² ë‹¤
>
> ìë°”ì—ì„œ long ìœ¼ë¡œ ì…ë ¥ë°›ê¸°ê°€ ì°¸ ë¶ˆí¸í•˜ë‹¤..

## í’€ì´ ğŸ“£

<hr/>

1ï¸âƒ£ ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ë¥¼ ë§Œë“œëŠ”ë°, êµ¬ê°„í•©ì„ ì €ì¥í•˜ë„ë¡ êµ¬í˜„í•œë‹¤.

2ï¸âƒ£ ë§Œì•½ ìˆ˜ì •í•´ì•¼í•  ê²½ìš°, ì…ë ¥ë°›ì€ ì¸ë±ìŠ¤ê°€ í¬í•¨ë˜ëŠ” êµ¬ê°„ ë…¸ë“œì— ì›ë˜ ê°’ê³¼ ë°”ê¾¸ë ¤ëŠ” ê°’ì˜ ì°¨ì´ë§Œí¼ì„ ì ìš©ì‹œì¼œì¤€ë‹¤.

3ï¸âƒ£ êµ¬ê°„íŠ¸ë¦¬ë¥¼ ëª¨ë‘ ìˆ˜ì •í•œ í›„, ì›ë˜ arrì— ìˆëŠ” ê°’ë„ ë§ˆì§€ë§‰ìœ¼ë¡œ ë³€ê²½í•´ì¤€ë‹¤.

4ï¸âƒ£ êµ¬ê°„ì˜ í•©ì„ ì¶œë ¥í•  ë•ŒëŠ” ë§Œë“¤ì–´ë†“ì€ êµ¬ê°„íŠ¸ë¦¬ë¥¼ í™œìš©í•´ì„œ í•´ë‹¹ ë²”ìœ„ì— ë§ëŠ” ë…¸ë“œê°’ì„ ëª¨ë‘ ë”í•´ì„œ ì¶œë ¥í•œë‹¤.

5ï¸âƒ£ ë¬¸ì œì—ì„œ ì…ë ¥ë°›ì€ ê°’ ë§Œí¼ ìœ„ì˜ ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.

<hr/>

## ì‹¤ìˆ˜ ğŸ˜…

- ê°’ì„ longìœ¼ë¡œ ë§Œë“¤ì–´ì¤˜ì•¼í•˜ëŠ” ê²ƒì„ ëª‡ ê°œ ë¹ ì ¸ë¨¹ì—ˆë‹¤.

- êµ¬ê°„íŠ¸ë¦¬ì˜ ê°’ì€ ëª¨ë‘ ë³€ê²½í•´ì¤¬ì§€ë§Œ, ì›ë˜ ìˆë˜ ë°°ì—´ì˜ ê°’ì„ ìˆ˜ì •í•˜ì§€ ì•Šì•„ì„œ ê³„ì† í‹€ë ¸ì—ˆë‹¤!
